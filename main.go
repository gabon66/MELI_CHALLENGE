package main

import (
	_ "CHALLENGE_MELI/docs" // docs is generated by Swag CLI, you have to import it.
	"CHALLENGE_MELI/helpers"
	"CHALLENGE_MELI/spaceModels"
	"fmt"
	"log"
	"net/http"

	"github.com/ReneKroon/ttlcache/v2"
	"github.com/gorilla/mux"
	httpSwagger "github.com/swaggo/http-swagger"
)

// inicio cache
var cache ttlcache.SimpleCache = ttlcache.NewCache()

/*
* GET request
 */
func index(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Meli Challenge -  Operacion ​ Fuego de Quasar")
}

// Valida en base a array de satelites coordenadas y mensaje de nave
// en caso de no poder calcular coordenadas o recuperar mensaje devuelve error.
func processTopSecret(w http.ResponseWriter, jsonData spaceModels.Satellites) {
	var distances []float32
	var messages [][]string

	for index := range jsonData.Satellites {
		distances = append(distances, jsonData.Satellites[index].Distance)
		messages = append(messages, jsonData.Satellites[index].Message)
	}

	cordsx, cordsy := helpers.GetLocation(distances...)
	msg := helpers.GetMessage(messages...)

	if cordsx == 0 && cordsy == 0 {

		http.Error(w, "No se puede obtener posicion", 404)
		return
	}

	if len(msg) == 0 {
		http.Error(w, "No se puede obtener obtener mensaje", 404)
		return
	}

	helpers.ResponseJson(w, helpers.CreateResponseTopSecret(msg, cordsx, cordsy))
}

// @Summary Valida posicion de nave
// @Description Valida posicion de nave en base a array de satelites
// @Accept  json
// @Produce  json
// @Success 200
// @Router /topsecret [post]
func TopSecret(w http.ResponseWriter, r *http.Request) {
	var jsonData spaceModels.Satellites

	err := helpers.DecodeJSONBody(w, r, &jsonData)
	if err != nil {
		helpers.ErroRequest(err, w)
		return
	}

	if len(jsonData.Satellites) >= 3 {
		processTopSecret(w, jsonData)
	} else {
		helpers.ErrorResponseNumberSatellites(w)
	}
}

// @Summary Valida posicion de nave
// @Description Valida posicion de nave en base a cache
// @Accept  json
// @Produce  json
// @Success 200
// @Router /topsecret_split [get]
func TopSecret_Split_Check(w http.ResponseWriter, r *http.Request) {
	// si entra por aca es para validar
	var satellites []spaceModels.Satellite
	for i := 0; i < 3; i++ {
		nameSat := helpers.GetNameFromFileByIndex(i)
		currentSat, dataStored := helpers.GetDataBySatelliteName(cache, nameSat)

		// valido si tengo distancia es que esta guardado
		if dataStored {
			satellites = append(satellites, currentSat)
		}
	}

	if len(satellites) == 3 {
		var allSat spaceModels.Satellites
		allSat.Satellites = satellites
		processTopSecret(w, allSat)
	} else {
		helpers.ErrorResponseNumberSatellites(w)
	}
}

// @Summary Guarda en cache datos por cada satelite
// @Description Guarda en cache datos por cada satelite
// @Accept  json
// @Produce  json
// @Success 200
// @Router /topsecret_split [post]
func TopSecret_Split_Save(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	satellite_name := vars["satellite_name"]

	if len(satellite_name) > 0 {

		var jsonData spaceModels.Satellite

		err := helpers.DecodeJSONBody(w, r, &jsonData)
		if err != nil {
			helpers.ErroRequest(err, w)
			return
		}

		helpers.SaveAndGetDataBySatelliteName(cache, satellite_name, jsonData)

	} else {
		fmt.Println(satellite_name)
		http.Error(w, "Nombre de satelite no provisto", 404)
	}
}

// @title MELI CHALLENGE
// @version 1.0
// @description CHALLENGE: Operacíon Fuego de Quasar
// @contact.name API Support
// @contact.email gabriel.adrian.felipe@gmail.com
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html
// @host localhost:4000
// @BasePath /
func main() {
	router := mux.NewRouter()

	fmt.Println("Listening on port :4000")

	router.HandleFunc("/topsecret", TopSecret).Methods("POST")
	router.HandleFunc("/topsecret_split", TopSecret_Split_Check).Methods("GET")                  // si es get es para validar coords y mensaje
	router.HandleFunc("/topsecret_split/{satellite_name}", TopSecret_Split_Save).Methods("POST") // dejo solo post para enviar data
	//Swagger
	router.PathPrefix("/swagger").Handler(httpSwagger.WrapHandler)

	log.Fatal(http.ListenAndServe(":4000", router))

}
